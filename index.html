<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Offline OSM Tile Manager</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }

    .toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1000;
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 8px;
      border-radius: 6px;
      font-family: system-ui, sans-serif;
    }

    .toolbar button {
      margin: 2px 0;
      width: 140px;
    }

    .panel {
      position: absolute;
      right: 0;
      top: 0;
      height: 100%;
      width: 380px;
      background: #111;
      color: #eee;
      z-index: 1000;
      overflow: auto;
      display: none;
      font-family: system-ui, sans-serif;
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px;
      border-bottom: 1px solid #333;
    }

    .panel-header h3 {
      margin: 0;
      font-size: 16px;
    }

    .panel-header button {
      background: none;
      border: none;
      color: #eee;
      font-size: 20px;
      cursor: pointer;
    }

    .tile-item {
      border-bottom: 1px solid #333;
      padding: 8px;
    }

    .tile-item small { color: #aaa; }
  </style>

  <script>
  if ('serviceWorker' in navigator) {
    try {
      const swCode = `
        const CACHE = 'osm-offline-v1';
        const CORE = [
          'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css',
          'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js'
        ];

        self.addEventListener('install', e => {
          e.waitUntil(caches.open(CACHE).then(c => c.addAll(CORE)));
        });

        self.addEventListener('fetch', e => {
          e.respondWith(
            caches.match(e.request).then(r => r || fetch(e.request).then(res => {
              const copy = res.clone();
              caches.open(CACHE).then(c => c.put(e.request, copy));
              return res;
            }).catch(() => r))
          );
        });
      `;

      const blob = new Blob([swCode], { type: 'text/javascript' });
      const swURL = URL.createObjectURL(blob);
      navigator.serviceWorker.register(swURL);
    } catch (e) {
      console.log('ServiceWorker skipped');
    }
  }
  </script>
</head>

<body>

<div id="map"></div>

<div class="toolbar">
  <button id="gpsBtn">Enable GPS</button><br>
  <button id="manageBtn">Manage tiles</button>
</div>

<div class="panel" id="panel"></div>

<script>
const DB_NAME = 'osm-tile-db';
const STORE = 'tiles';

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = e => {
      const db = e.target.result;
      const store = db.createObjectStore(STORE, { keyPath: 'id' });
      store.createIndex('zxy', ['z','x','y']);
    };
    req.onsuccess = e => resolve(e.target.result);
    req.onerror = e => reject(e);
  });
}

async function saveTile(tile) {
  const db = await openDB();
  const tx = db.transaction(STORE, 'readwrite');
  tx.objectStore(STORE).put(tile);
}

async function getAllTiles() {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const req = tx.objectStore(STORE).getAll();
    req.onsuccess = () => resolve(req.result || []);
    req.onerror = () => reject(req.error);
  });
}

async function getCachedTile(z, x, y) {
  const tiles = await getAllTiles();
  return tiles.find(t => t.z === z && t.x === x && t.y === y);
}

function panelHeader(title) {
  return `
    <div class="panel-header">
      <h3>${title}</h3>
      <button id="closePanelBtn">Ã—</button>
    </div>
  `;
}

class CachedTileLayer extends L.TileLayer {
  async _loadTile(tile, tilePoint) {
    const { z, x, y } = tilePoint;
    const cached = await getCachedTile(z, x, y);
    if (cached) {
      tile.src = URL.createObjectURL(cached.blob);
      tile.classList.add('leaflet-tile-loaded');
      this.fire('tileload', { tile, coords: tilePoint });
      return;
    }
    super._loadTile(tile, tilePoint);
  }
}

const map = L.map('map').setView([39.7, -8.9], 11);

const tileLayer = new CachedTileLayer(
  'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
  { maxZoom: 19, crossOrigin: true }
);

tileLayer.addTo(map);

const panel = document.getElementById('panel');

map.on('contextmenu', async e => {
  panel.style.display = 'block';

  const { lat, lng } = e.latlng;
  const zoom = map.getZoom();

  const tileX = Math.floor((lng + 180) / 360 * Math.pow(2, zoom));
  const tileY = Math.floor(
    (1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2
    * Math.pow(2, zoom)
  );

  const tiles = await getAllTiles();
  const matchingTile = tiles.filter(t => t.z === zoom && t.x === tileX && t.y === tileY);

  panel.innerHTML = panelHeader(`Tile at z:${zoom} x:${tileX} y:${tileY}`);

  document.getElementById('closePanelBtn').onclick = () => {
    panel.style.display = 'none';
  };

  if (!matchingTile.length) {
    panel.innerHTML += '<p style="padding:8px">No cached tile at this location.</p>';
    return;
  }

  matchingTile.forEach(t => {
    const div = document.createElement('div');
    div.className = 'tile-item';
    div.innerHTML = `
      <div>z:${t.z} x:${t.x} y:${t.y}</div>
      <small>${t.downloadedAt}</small><br>
      <img style="margin-top:6px;border:1px solid #333;width:256px;height:256px"
           src="${URL.createObjectURL(t.blob)}"><br>
      <button data-id="${t.id}" class="delete">Delete</button>
    `;
    panel.appendChild(div);
  });

  panel.querySelectorAll('.delete').forEach(b => {
    b.onclick = async () => {
      const db = await openDB();
      const tx = db.transaction(STORE, 'readwrite');
      tx.objectStore(STORE).delete(b.dataset.id);
      panel.style.display = 'none';
    };
  });
});

document.getElementById('manageBtn').onclick = async () => {
  panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
  if (panel.style.display === 'block') renderPanel();
};

async function renderPanel() {
  const tiles = await getAllTiles();
  panel.innerHTML = panelHeader('Cached tiles');

  document.getElementById('closePanelBtn').onclick = () => {
    panel.style.display = 'none';
  };

  tiles.forEach(t => {
    const div = document.createElement('div');
    div.className = 'tile-item';
    div.innerHTML = `
      <div>z:${t.z} x:${t.x} y:${t.y}</div>
      <small>${t.downloadedAt}</small><br>
      <img style="margin-top:6px;border:1px solid #333;width:256px;height:256px"
           src="${URL.createObjectURL(t.blob)}"><br>
      <button data-id="${t.id}" class="delete">Delete</button>
    `;
    panel.appendChild(div);
  });

  panel.querySelectorAll('.delete').forEach(b => {
    b.onclick = async () => {
      const db = await openDB();
      const tx = db.transaction(STORE, 'readwrite');
      tx.objectStore(STORE).delete(b.dataset.id);
      renderPanel();
    };
  });
}

let watchId = null;
const gpsBtn = document.getElementById('gpsBtn');
const marker = L.circleMarker([0,0], { radius: 6, color: 'red' });

gpsBtn.onclick = () => {
  if (watchId) {
    navigator.geolocation.clearWatch(watchId);
    watchId = null;
    gpsBtn.textContent = 'Enable GPS';
    return;
  }

  watchId = navigator.geolocation.watchPosition(pos => {
    const latlng = [pos.coords.latitude, pos.coords.longitude];
    marker.setLatLng(latlng).addTo(map);
    map.setView(latlng, map.getZoom(), { animate: true });
  });

  gpsBtn.textContent = 'Disable GPS';
};
</script>

</body>
</html>
