<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Offline OSM Tile Manager</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="manifest" href="./manifest.json">
<meta name="theme-color" content="#111111">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }

    .toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1000;
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 8px;
      border-radius: 6px;
      font-family: system-ui, sans-serif;
    }

    .toolbar button {
      margin: 2px 0;
      width: 140px;
    }

    .panel {
      position: absolute;
      right: 0;
      top: 0;
      height: 100%;
      width: 380px;
      background: #111;
      color: #eee;
      z-index: 1000;
      overflow: auto;
      display: none;
      font-family: system-ui, sans-serif;
    }

    .tile-item {
      border-bottom: 1px solid #333;
      padding: 8px;
    }

    .tile-item small { color: #aaa; }
  </style>
  <script>
  // --- Minimal service worker for full offline support ---
  if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js');
  });
}

  </script>
</head>
<body>

<div id="map"></div>

<div class="toolbar">
  <button id="gpsBtn">Enable GPS</button><br>
  <button id="manageBtn">Manage tiles</button>
</div>

<div class="panel" id="panel"></div>

<script>
// --- IndexedDB for tile versioning ---
const DB_NAME = 'osm-tile-db';
const STORE = 'tiles';

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = e => {
      const db = e.target.result;
      const store = db.createObjectStore(STORE, { keyPath: 'id' });
      store.createIndex('zxy', ['z','x','y']);
    };
    req.onsuccess = e => resolve(e.target.result);
    req.onerror = e => reject(e);
  });
}

async function saveTile(tile) {
  const db = await openDB();
  const tx = db.transaction(STORE, 'readwrite');
  tx.objectStore(STORE).put(tile);
}

async function getAllTiles() {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const req = tx.objectStore(STORE).getAll();
    req.onsuccess = () => resolve(req.result || []);
    req.onerror = () => reject(req.error);
  });
}

// --- Custom tile layer that checks cache first ---
class CachedTileLayer extends L.TileLayer {
  async _loadTile(tile, tilePoint) {
    const { z, x, y } = tilePoint;
    
    // Check cache first
    const cached = await getCachedTile(z, x, y);
    if (cached) {
      tile.src = URL.createObjectURL(cached.blob);
      tile.classList.add('leaflet-tile-loaded');
      this.fire('tileload', { tile, coords: tilePoint });
      return;
    }

    // Not in cache, fetch from OSM
    super._loadTile(tile, tilePoint);
  }

  async _tileOnLoad(done, tile) {
    try {
      // Extract z,x,y from tile src URL
      const match = tile.src.match(/\/(\d+)\/(\d+)\/(\d+)\./);
      if (match) {
        const [, z, x, y] = match;
        const z_int = parseInt(z), x_int = parseInt(x), y_int = parseInt(y);
        
        // Check if tile is already cached - don't save duplicate
        const alreadyCached = await getCachedTile(z_int, x_int, y_int);
        if (!alreadyCached) {
          const canvas = document.createElement('canvas');
          canvas.width = tile.naturalWidth || 256;
          canvas.height = tile.naturalHeight || 256;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(tile, 0, 0);

          const blob = await new Promise(r => canvas.toBlob(r));
          
          await saveTile({
            id: crypto.randomUUID(),
            z: z_int, x: x_int, y: y_int,
            bbox: tileBBox(x_int, y_int, z_int),
            downloadedAt: new Date().toISOString(),
            blob
          });
        }
      }
    } catch (e) {
      console.log('Error caching tile:', e);
    }

    super._tileOnLoad(done, tile);
  }
}

// Helper to get tile from cache
async function getCachedTile(z, x, y) {
  const tiles = await getAllTiles();
  return tiles.find(t => t.z === z && t.x === x && t.y === y);
}

// --- Leaflet map ---
const map = L.map('map').setView([0, 0], 1);

const tileLayer = new CachedTileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: '&copy; OpenStreetMap contributors',
  crossOrigin: true
});

tileLayer.addTo(map);

// --- Right click: show only the map tile at clicked coordinate ---
map.on('contextmenu', async e => {
  panel.style.display = 'block';
  const { lat, lng } = e.latlng;
  const zoom = map.getZoom();

  const tileX = Math.floor((lng + 180) / 360 * Math.pow(2, zoom));
  const tileY = Math.floor(
    (1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom)
  );

  const tiles = await getAllTiles();

  const matchingTile = tiles.filter(t =>
    t.z === zoom &&
    t.x === tileX &&
    t.y === tileY
  );

  panel.innerHTML = `<h3 style="padding:8px">Tile at z:${zoom} x:${tileX} y:${tileY}</h3>`;

  if (!matchingTile.length) {
    panel.innerHTML += '<p style="padding:8px">No cached tile at this location and zoom level.</p>';
    return;
  }

  matchingTile.forEach(t => {
    const div = document.createElement('div');
    div.className = 'tile-item';
    div.innerHTML = `
      <div>z:${t.z} x:${t.x} y:${t.y}</div>
      <small>${toRelativeTime(t.downloadedAt)}</small><br>
      <img style="margin-top:6px;border:1px solid #333;width:256px;height:256px" src="${URL.createObjectURL(t.blob)}"><br>
      <button data-id="${t.id}" class="update">Update</button>
      <button data-id="${t.id}" class="delete">Delete</button>
    `;
    panel.appendChild(div);
  });

  panel.querySelectorAll('.update').forEach(b => {
    b.onclick = () => updateTile(b.dataset.id);
  });

  panel.querySelectorAll('.delete').forEach(b => {
    b.onclick = async () => {
      const db = await openDB();
      const tx = db.transaction(STORE, 'readwrite');
      tx.objectStore(STORE).delete(b.dataset.id);
      map.fire('contextmenu', { latlng: e.latlng });
    };
  });
});

// --- Tile management ---
function tileBBox(x, y, z) {
  const n = Math.pow(2, z);
  const lon1 = x / n * 360 - 180;
  const lon2 = (x + 1) / n * 360 - 180;
  const lat1 = rad2deg(Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n))));
  const lat2 = rad2deg(Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 1) / n))));
  return { latMin: lat2, latMax: lat1, lonMin: lon1, lonMax: lon2 };
}

function rad2deg(r) { return r * 180 / Math.PI; }

// --- Tile manager UI ---
const panel = document.getElementById('panel');

document.getElementById('manageBtn').onclick = async () => {
  panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
  if (panel.style.display === 'block') renderPanel();
};

document.getElementById('panel').onclick = async () => {
  panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
  
};

function toRelativeTime(isoString, locale = navigator.language) {
  const date = new Date(isoString);
  const now = new Date();

  const diffMs = date - now;
  const diffSec = Math.round(diffMs / 1000);

  const rtf = new Intl.RelativeTimeFormat(locale, { numeric: "auto" });

  const units = [
    { name: "year",   seconds: 31536000 },
    { name: "month",  seconds: 2592000 },
    { name: "day",    seconds: 86400 },
    { name: "hour",   seconds: 3600 },
    { name: "minute", seconds: 60 },
    { name: "second", seconds: 1 }
  ];

  for (const unit of units) {
    const value = Math.trunc(diffSec / unit.seconds);
    if (Math.abs(value) >= 1) {
      return rtf.format(value, unit.name);
    }
  }

  return rtf.format(0, "second");
}

async function renderPanel() {
  const tiles = await getAllTiles();
  panel.innerHTML = '<h3 style="padding:8px">Cached tiles</h3>';

  tiles.forEach(t => {
    const div = document.createElement('div');
    div.className = 'tile-item';
    div.innerHTML = `
      <div>z:${t.z} x:${t.x} y:${t.y}</div>
      <small>${toRelativeTime(t.downloadedAt)}</small><br>
      <small>bbox: ${t.bbox.latMin.toFixed(4)}, ${t.bbox.lonMin.toFixed(4)} â†’ ${t.bbox.latMax.toFixed(4)}, ${t.bbox.lonMax.toFixed(4)}</small><br>
      <img style="margin-top:6px;border:1px solid #333;width:256px;height:256px;object-fit:contain" src="${URL.createObjectURL(t.blob)}"><br>
      <button data-id="${t.id}" class="update">Update</button>
      <button data-id="${t.id}" class="delete">Delete</button>
    `;
    panel.appendChild(div);
  });

  panel.querySelectorAll('.update').forEach(b => {
    b.onclick = () => updateTile(b.dataset.id);
  });

  panel.querySelectorAll('.delete').forEach(b => {
    b.onclick = async () => {
      const db = await openDB();
      const tx = db.transaction(STORE, 'readwrite');
      tx.objectStore(STORE).delete(b.dataset.id);
      renderPanel();
    };
  });
}

async function updateTile(id) {
  const tiles = await getAllTiles();
  const t = tiles.find(t => t.id === id);
  if (!t) return;

  const url = `https://tile.openstreetmap.org/${t.z}/${t.x}/${t.y}.png`;
  const res = await fetch(url);
  const blob = await res.blob();

  await saveTile({
    ...t,
    id: crypto.randomUUID(),
    blob,
    downloadedAt: new Date().toISOString()
  });

  renderPanel();
}

// --- GPS live tracking ---
let watchId = null;
const gpsBtn = document.getElementById('gpsBtn');

const marker = L.circleMarker([0,0], { radius: 6, color: 'red' });

gpsBtn.onclick = () => {
  if (watchId) {
    navigator.geolocation.clearWatch(watchId);
    watchId = null;
    gpsBtn.textContent = 'Enable GPS';
    return;
  }

  watchId = navigator.geolocation.watchPosition(pos => {
    const latlng = [pos.coords.latitude, pos.coords.longitude];
    marker.setLatLng(latlng).addTo(map);
    map.setView(latlng, map.getZoom(), { animate: true });
  });

  gpsBtn.textContent = 'Disable GPS';
};
</script>

</body>
</html>

